<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Feedback Experiment / 画像フィードバック実験</title>
    <style>
        /* CSS (デザイン) */
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
            background-color: #f0f0f0;
        }
        .lang-switcher {
            position: absolute;
            top: 15px;
            right: 20px;
        }
        .lang-switcher button {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1em;
            color: #007bff;
            padding: 5px;
            text-decoration: underline;
        }
        #start-screen {
            max-width: 800px; padding: 40px;
            background-color: white; border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1); text-align: left;
        }
        #start-screen h1 { text-align: center; }
        #start-screen ul, #start-screen ol { padding-left: 20px; }
        #start-experiment-btn {
            display: block; width: 60%;
            margin: 30px auto 0; padding: 15px;
            font-size: 1.2em; cursor: pointer;
            background-color: #007bff; color: white;
            border: none; border-radius: 5px;
        }
        #experiment-screen {
            display: none; flex-direction: column;
            align-items: center;
        }
        .image-container {
            position: relative; width: 800px;
            height: 600px; border: 1px solid #ccc;
            background-color: #fff;
        }
        #mainImage { width: 100%; height: 100%; object-fit: contain; }
        canvas {
            position: absolute; top: 0; left: 0;
            width: 100%; height: 100%;
            cursor: crosshair; display: none;
        }
        .controls {
            display: flex; align-items: center;
            gap: 15px; margin-top: 10px;
        }
        .btn {
            font-size: 1.1em; padding: 8px 20px;
            cursor: pointer; color: white;
            border: none; border-radius: 5px;
        }
        #mappingBtn { background-color: #007bff; }
        #undoBtn { background-color: #ffc107; color: black; }
        #mappingBtn:disabled, #undoBtn:disabled {
            background-color: #ccc; cursor: not-allowed;
        }
        #stateSelectionModal {
            display: none; position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px; background-color: white;
            border: 1px solid #ccc; box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000; border-radius: 10px;
        }
        .state-options { display: flex; flex-direction: column; gap: 10px; }
        #instruction {
            margin-top: 10px; font-weight: bold;
            color: #d9534f; height: 20px;
        }
    </style>
</head>
<body>

    <div class="lang-switcher">
        <button id="lang-ja">日本語</button> / <button id="lang-en">English</button>
    </div>

    <div id="start-screen">
        <h1 data-translate="welcome_title"></h1>
        <p data-translate="welcome_intro"></p>
        <h3 data-translate="overview_title"></h3>
        <ul data-translate="overview_list"></ul>
        <h3 data-translate="how_to_title"></h3>
        <ol data-translate="how_to_list"></ol>
        <button id="start-experiment-btn" data-translate="start_button"></button>
    </div>

    <div id="experiment-screen">
        <h2 id="session-title"></h2>
        <div class="image-container">
            <img id="mainImage" src="" alt="Experiment Image">
            <canvas id="drawingCanvas"></canvas>
        </div>
        <div class="controls">
            <button id="mappingBtn" class="btn" data-translate="mapping_button"></button>
            <button id="undoBtn" class="btn" data-translate="undo_button" disabled></button>
        </div>
        <div id="instruction"></div>
    </div>

    <div id="stateSelectionModal">
        <h3 data-translate="modal_title"></h3>
        <div class="state-options">
            <label><input type="checkbox" name="state" value="Clean"> <span data-translate="state_clean"></span></label>
            <label><input type="checkbox" name="state" value="Scattered"> <span data-translate="state_scattered"></span></label>
            <label><input type="checkbox" name="state" value="Broken"> <span data-translate="state_broken"></span></label>
            <label><input type="checkbox" name="state" value="Wet"> <span data-translate="state_wet"></span></label>
            <label><input type="checkbox" name="state" value="Risk"> <span data-translate="state_risk"></span></label>
        </div>
        <br>
        <button id="startDrawingBtn" class="btn" data-translate="start_drawing_button"></button>
    </div>

    <script>
    // --- ★★★ 実験設定 ★★★ ---
    const practiceImages = [ 'images/practice1.jpg', 'images/practice2.jpg', 'images/practice3.jpg', 'images/practice4.jpg' ];
   const mainImages = [
            'images/kitchen_clutter_01.png',
            'images/kitchen_clutter_02.png',
            'images/kitchen_wet_01.png',
            'images/kitchen_wet_02.png',
            'images/student_space_risk_01.png',
            'images/student_space_risk_02.png',
            'images/student_space_risk_03.png',
            'images/student_space_risk_04.png'
        ];
    const a_gas_url = 'https://script.google.com/macros/s/AKfycbzO-eA9nXtnTD3jSLdvDiagWK2xQZ1wotjPWOTpOrFakRkZKrlP1sdv5aGeUWV4gCFRWg/exec';
    // --- ★★★ 設定はここまで ★★★ ---

    // --- テキスト管理 ---
    const translations = {
        welcome_title: { ja: "フィードバック実験へようこそ", en: "Welcome to the Feedback Experiment" },
        welcome_intro: { ja: "この実験にご協力いただき、ありがとうございます。以下の説明をよくお読みの上、ご参加ください。", en: "Thank you for participating in this experiment. Please read the instructions below carefully before you begin." },
        overview_title: { ja: "実験の概要", en: "Experiment Overview" },
        overview_list: {
            ja: `<li>合計12枚（練習4枚、本番8枚）の画像を見て、特定の状態が感じられる箇所を四角形で囲っていただきます。</li>
                 <li>対象となる状態は <strong>{清潔, 散乱, 濡れ, 壊れている, リスクがある}</strong> の5つです。</li>
                 <li>1つの箇所に対して、複数の状態を定義することも可能です。（例：「濡れていてリスクがある」など）</li>`,
            en: `<li>You will be shown a total of 12 images (4 for practice, 8 for the main task). For each image, you will draw rectangles around areas where you perceive certain states.</li>
                 <li>The states are: <strong>{Clean, Scattered, Wet, Broken, Risk}</strong>.</li>
                 <li>It is possible to define multiple states for the same area (e.g., an area can be both "Wet" and a "Risk").</li>`
        },
        how_to_title: { ja: "操作方法", en: "How to Operate" },
        how_to_list: {
            ja: `<li>「マッピング」ボタンを押し、画像から感じる状態を複数選択します。</li>
                 <li>「描画を開始」ボタンを押します。</li>
                 <li>指示に従い、該当する箇所をマウスでドラッグして四角で囲みます。</li>
                 <li>選択した全ての状態について描画が完了すると、データが自動で保存され、次の画像に進みます。</li>`,
            en: `<li>Click the "Mapping" button and select one or more states you perceive in the image.</li>
                 <li>Click the "Start Drawing" button.</li>
                 <li>Follow the instructions to draw a rectangle by dragging your mouse over the corresponding area.</li>
                 <li>Once you have drawn areas for all selected states, the data will be saved automatically, and you will proceed to the next image.</li>`
        },
        start_button: { ja: "練習を開始する", en: "Start Practice" },
        mapping_button: { ja: "マッピング", en: "Mapping" },
        undo_button: { ja: "一つ前に戻る", en: "Undo" },
        modal_title: { ja: "あなたの感じる状態を選択してください (複数選択可)", en: "Select the state(s) you perceive (multiple selections allowed)" },
        state_clean: { ja: "清潔", en: "Clean" },
        state_scattered: { ja: "散乱", en: "Scattered" },
        state_broken: { ja: "壊れている", en: "Broken" },
        state_wet: { ja: "濡れ", en: "Wet" },
        state_risk: { ja: "リスクがある", en: "Risk" },
        start_drawing_button: { ja: "描画を開始", en: "Start Drawing" },
        session_practice: { ja: "練習セッション", en: "Practice Session" },
        session_main: { ja: "本番セッション", en: "Main Session" },
        instruction_image: { ja: (current, total) => `画像 ${current} / ${total}`, en: (current, total) => `Image ${current} / ${total}` },
        instruction_draw: { ja: (state) => `【${state}】と感じる部分を四角で囲ってください。`, en: (state) => `Please draw a rectangle around the area you feel is [${state}].` },
        alert_practice_end: { ja: "練習はこれで終わりです。次に本番のセッションを開始します。", en: "The practice session is now complete. The main session will begin next." },
        alert_experiment_end: { ja: "全ての実験が終了しました。ご協力ありがとうございました。", en: "The experiment is now finished. Thank you for your cooperation." },
        alert_select_state: { ja: "少なくとも1つの状態を選択してください。", en: "Please select at least one state." },
        status_saving: { ja: "データを保存中...", en: "Saving data..." },
        status_save_complete: { ja: "データの保存が完了しました。", en: "Save complete." },
        status_save_error: { ja: "エラー：データの保存に失敗しました。", en: "Error: Failed to save data." },
        status_practice_complete: { ja: "練習完了。次の画像に進みます。", en: "Practice complete. Proceeding to the next image." },
    };

    let currentLang = 'ja';

    // --- 言語切替機能 ---
    function setLanguage(lang) {
        currentLang = lang;
        document.documentElement.lang = lang;
        document.querySelectorAll('[data-translate]').forEach(el => {
            const key = el.dataset.translate;
            if (translations[key] && translations[key][lang]) {
                el.innerHTML = translations[key][lang];
            }
        });
        // チェックボックスのvalueも言語に合わせて変更
        document.querySelectorAll('.state-options input[type="checkbox"]').forEach(checkbox => {
            const stateKey = `state_${checkbox.nextElementSibling.dataset.translate.split('_')[1]}`;
            if (translations[stateKey]) {
                const stateInEnglish = translations[stateKey]['en'];
                checkbox.value = stateInEnglish;
            }
        });
    }
    document.getElementById('lang-ja').addEventListener('click', () => setLanguage('ja'));
    document.getElementById('lang-en').addEventListener('click', () => setLanguage('en'));
    
    // --- 要素取得と変数定義 (変更なし) ---
    const startScreen = document.getElementById('start-screen');
    const experimentScreen = document.getElementById('experiment-screen');
    const startExperimentBtn = document.getElementById('start-experiment-btn');
    const sessionTitle = document.getElementById('session-title');
    const mainImage = document.getElementById('mainImage');
    const mappingBtn = document.getElementById('mappingBtn');
    const undoBtn = document.getElementById('undoBtn');
    const stateSelectionModal = document.getElementById('stateSelectionModal');
    const startDrawingBtn = document.getElementById('startDrawingBtn');
    const canvas = document.getElementById('drawingCanvas');
    const instruction = document.getElementById('instruction');
    const ctx = canvas.getContext('2d');
    let currentImageList = [], currentImageIndex = 0, isPractice = true, selectedStates = [], currentStateIndex = 0, annotations = {}, drawnRects = [], isDrawing = false, startX, startY;
    
    // --- 実験フロー (動的テキスト部分を修正) ---
    startExperimentBtn.addEventListener('click', () => {
        startScreen.style.display = 'none';
        experimentScreen.style.display = 'flex';
        startSession(true);
    });

    function startSession(isPracticeSession) {
        isPractice = isPracticeSession;
        currentImageIndex = 0;
        if (isPractice) {
            sessionTitle.textContent = translations.session_practice[currentLang];
            currentImageList = practiceImages;
        } else {
            sessionTitle.textContent = translations.session_main[currentLang];
            currentImageList = mainImages;
        }
        loadImage();
    }

    function loadImage() {
        if (currentImageIndex >= currentImageList.length) {
            if (isPractice) {
                alert(translations.alert_practice_end[currentLang]);
                startSession(false);
            } else {
                experimentScreen.innerHTML = `<h1>${translations.alert_experiment_end[currentLang]}</h1>`;
            }
            return;
        }
        
        const imageName = currentImageList[currentImageIndex];
        mainImage.crossOrigin = "Anonymous";
        mainImage.src = imageName;
        mainImage.onload = () => {
            const container = document.querySelector('.image-container');
            canvas.width = mainImage.naturalWidth;
            canvas.height = mainImage.naturalHeight;
            container.style.width = mainImage.clientWidth + 'px';
            container.style.height = mainImage.clientHeight + 'px';
        };
        mappingBtn.disabled = false;
        instruction.textContent = translations.instruction_image[currentLang](currentImageIndex + 1, currentImageList.length);
    }

    startDrawingBtn.addEventListener('click', () => {
        const checkedBoxes = document.querySelectorAll('input[name="state"]:checked');
        if (checkedBoxes.length === 0) {
            alert(translations.alert_select_state[currentLang]);
            return;
        }
        selectedStates = Array.from(checkedBoxes).map(cb => cb.value);
        currentStateIndex = 0;
        annotations = {};
        drawnRects = [];
        stateSelectionModal.style.display = 'none';
        canvas.style.display = 'block';
        mappingBtn.disabled = true;
        undoBtn.disabled = false;
        startDrawingForCurrentState();
    });

    function startDrawingForCurrentState() {
        if (currentStateIndex >= selectedStates.length) {
            finishMapping();
            return;
        }
        const currentState = selectedStates[currentStateIndex];
        instruction.textContent = translations.instruction_draw[currentLang](currentState);
        canvas.addEventListener('mousedown', onMouseDown);
        canvas.addEventListener('mousemove', onMouseMove);
        canvas.addEventListener('mouseup', onMouseUp);
    }

    undoBtn.addEventListener('click', () => {
        if (currentStateIndex === 0) return;
        currentStateIndex--;
        const lastState = selectedStates[currentStateIndex];
        delete annotations[lastState];
        drawnRects.pop();
        redrawCanvas();
        instruction.textContent = translations.instruction_draw[currentLang](lastState);
    });
    
    function finishMapping() {
        instruction.textContent = translations.status_saving[currentLang];
        canvas.removeEventListener('mousedown', onMouseDown);
        canvas.removeEventListener('mousemove', onMouseMove);
        canvas.removeEventListener('mouseup', onMouseUp);
        undoBtn.disabled = true;
        if (isPractice) {
            console.log("Practice data:", { imageName: currentImageList[currentImageIndex], annotations: annotations });
            instruction.textContent = translations.status_practice_complete[currentLang];
            resetForNextImage(1500);
        } else {
            saveDataToServer();
        }
    }

    function saveDataToServer() {
        if (!a_gas_url || a_gas_url.includes('貼り付け')) {
            console.error("GAS URL is not set.");
            instruction.textContent = "Error: Submission URL is not configured. Saving locally for test.";
            resetForNextImage(2000);
            return;
        }
        const dataToSend = {
            imageName: currentImageList[currentImageIndex],
            annotations: annotations,
            imageDataUrl: getAnnotatedImageDataUrl()
        };
        fetch(a_gas_url, { method: 'POST', mode: 'no-cors', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(dataToSend)})
        .then(() => {
            console.log('Data submission successful.');
            instruction.textContent = translations.status_save_complete[currentLang];
        })
        .catch(error => {
            console.error('Data submission failed:', error);
            instruction.textContent = translations.status_save_error[currentLang];
        })
        .finally(() => { resetForNextImage(2000); });
    }

    function resetForNextImage(delay) {
        setTimeout(() => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            canvas.style.display = 'none';
            document.querySelectorAll('input[name="state"]:checked').forEach(cb => cb.checked = false);
            currentImageIndex++;
            loadImage();
        }, delay);
    }
    
    // --- ページの初期化 ---
    document.addEventListener('DOMContentLoaded', () => {
        setLanguage('ja'); // デフォルト言語を日本語に設定
    });
    
    // --- 変更不要な関数群 ---
    mappingBtn.addEventListener('click', () => { stateSelectionModal.style.display = 'block'; });
    function redrawCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 3;
        drawnRects.forEach(rect => { ctx.strokeRect(rect.x, rect.y, rect.width, rect.height); });
    }
    function onMouseDown(e) {
        isDrawing = true; const rect = canvas.getBoundingClientRect();
        startX = (e.clientX - rect.left) * (canvas.width / rect.width);
        startY = (e.clientY - rect.top) * (canvas.height / rect.height);
    }
    function onMouseMove(e) {
        if (!isDrawing) return; const rect = canvas.getBoundingClientRect();
        const currentX = (e.clientX - rect.left) * (canvas.width / rect.width);
        const currentY = (e.clientY - rect.top) * (canvas.height / rect.height);
        redrawCanvas();
        ctx.strokeRect(startX, startY, currentX - startX, currentY - startY);
    }
    function onMouseUp(e) {
        if (!isDrawing) return; isDrawing = false; const rect = canvas.getBoundingClientRect();
        const endX = (e.clientX - rect.left) * (canvas.width / rect.width);
        const endY = (e.clientY - rect.top) * (canvas.height / rect.height);
        const newRect = { x: Math.min(startX, endX), y: Math.min(startY, endY), width: Math.abs(endX - startX), height: Math.abs(endY - startY) };
        const currentState = selectedStates[currentStateIndex];
        annotations[currentState] = newRect;
        drawnRects.push(newRect);
        currentStateIndex++;
        startDrawingForCurrentState();
    }
    function getAnnotatedImageDataUrl() {
        const tempCanvas = document.createElement('canvas'); tempCanvas.width = mainImage.naturalWidth; tempCanvas.height = mainImage.naturalHeight;
        const tempCtx = tempCanvas.getContext('2d'); tempCtx.drawImage(mainImage, 0, 0);
        tempCtx.strokeStyle = 'lime'; tempCtx.lineWidth = 5;
        Object.values(annotations).forEach(rect => { tempCtx.strokeRect(rect.x, rect.y, rect.width, rect.height); });
        return tempCanvas.toDataURL('image/png');
    }
    </script>
</body>
</html>